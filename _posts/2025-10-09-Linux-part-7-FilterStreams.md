---
layout: post
title: قسمت هفتم آموزش لینوکس - Stream Filters
date: 2025-10-09 03:00:00 +0330
categories: linux lpic threat-hunting streams
image: /assets/images/od_command.png
description: اینجا دوباره بر میگردیم به Terminal لینوکس و سعی میکنیم یکم با streamهای متنی که توش هست بازی کنیم.
tag:
  - linux
  - kernel_module
  - stream
author: amin Ghorbani
---
## استریم‌های متنی در لینوکس در خط فرمان

خب تو پست قبلی یه شبیه سازی از حملات لینوکس کردیم که لزوم یادگیری لینوکس رو کمی درک کنیم.
در این پست قصد داریم استریم‌های متنی لینوکس رو یاد بگیریم.

ابتدای این پست بنا رو میذاریم که شما تازه دارید با لینوکس آشنا میشوید و نیاز دارید یکم دستورات ساده لینوکس رو یاد بگیرید تا بعد یکم عمیق‌تر بشیم روش.
دستور cat رو به احتمال خیلی زیاد میشناسید شما زمانی که میخواهید محتوای یک فایل رو بخونید میتونید از این دستور استفاده کنید.

```bash
cat file.txt
```

دستور بعدی less هست، این دستور همون کار cat رو میکنه اما برای فایل های بزرگ که با cat درست نمیشه خوندشون مثلا فرض کنید من میخوام لاگ های سیستم رو بخونم، اینجا اگر cat کنم حجم زیادی متن خونده و نمایش داده میشه. شما با دستور less میتونید این فایل رو صفحه صفحه بخونید و با دکمه ها page down و page up هم به صفحات بعد و قبل بروید و با دکمه q از آن خارج شوید

```bash
less boot.log-20250415
```

اما خب این دو دستور هردوتاشون برای فایل های متنی بود. فرض کنید من یه فایل باینری رو میخوام بخونم اونجا از دستور od استفاده میکنم.

```bash
od cat
```

اینجا به شما octal یعنی در مبنای 8 فایل رو نشون میده
![خروجی od](/assets/images/od_command.png)

شکل بالا خروجی دستور od است که ستون زرد رنگ در حقیقت آدرس‌های باینری و هر سطر مقابلش مقدار داخلش رو به ما نمایش میدهد. برای اینکه مقادیر رو تبدیل به کاراکترها کنید که کمی خواناتر بشه این دستور رو با سوییچ c- اجرا کنید.

```bash
od -c cat
```

### جداکردن اجزای فایل ها

دستور split برای جداکردن و تکه تکه کردن فایل ها استفاده میشود. این دستور سوییچ های جذابی داره :
-b: براساس بایت 
-l: براساس تعداد خط
-n: تعداد تکه هایی که میخواهیم فایل را به آن تقسیم کنیم

```bash
split -b30k boot.log
```

![خروجی split](/assets/images/split_command.png)
در دستور split دیدیم که وقتی فایل boot.log رو split کردیم فایل های جدیدی ساخته شد، اما ممکن است ما نخواهیم اینکار رو کنیم و مثلا n خط اول یه فایل رو بخواهیم بخوانیم یا m خط اخرش رو بخوایم بخونیم اینجا میتونیم از دستورات head و tail استفاده کنیم.

```bash
head -5 boot.log
```
![خروجی head](/assets/images/head_command.png)

```bash
tail -5 boot.log
```

![خروجی tail](/assets/images/tail_command.png) 

### تغییر استریم ها

دستور sort از اسمش مشخصه  چیکار میکنه sort برای مرتب کردن خروجی است یعنی چی؟ 
مرتب کردن برعکس چیزی که فکر میکنید یکم ریزه کاری داره مثلا فرض کنید من یه فایل دارم که محتواش به شرح زیر است:

```text
4 salam
8 bye bye
11 new line
```

حالا دستور sort رو میزنم:
```bash
sort text
```

![خروجی sort](/assets/images/sort_command.png)
دقت کنید خط اولی که نمایش میده 11 و خط دوم 4 است درحالی که 11 بزرگتر از 4 است. دلیلش اینه فقط کاراکترهای اول رو مقایسه میکنه حالا اگر در دو خط کاراکتر اول خط ها یکسان بود کاراکترهای دوم رو مقایسه میکنه. اگر بخوایم بر اساس اعداد مرتب سازی رو انجام بده کافیه از سوییچ n- استفاده کنیم:
![خروجی sort با n-](/assets/images/sort_by_num.png)

اما بین a و A کدوم بزرگتره؟ اصلا a بزرگتره یا 1؟ در مرتب سازی شما وقتی از سیستم میخواهید اینکار رو کنه اتفاقی که میافته این مرتب سازی براساس جدول ascii رخ میده، یعنی سیستم میاد کاراکترها رو به کد ascii تبدیل میکنه و بعد براساس اون کدها مرتب سازی میکنه.

|Dec|Hex|Char|Dec|Hex|Char|Dec|Hex|Char|Dec|Hex|Char|
|---|---|---|---|---|---|---|---|---|---|---|---|
|0|00|NUL|1|01|SOH|2|02|STX|3|03|ETX|
|4|04|EOT|5|05|ENQ|6|06|ACK|7|07|BEL|
|8|08|BS|9|09|TAB|10|0A|LF|11|0B|VT|
|12|0C|FF|13|0D|CR|14|0E|SO|15|0F|SI|
|16|10|DLE|17|11|DC1|18|12|DC2|19|13|DC3|
|20|14|DC4|21|15|NAK|22|16|SYN|23|17|ETB|
|24|18|CAN|25|19|EM|26|1A|SUB|27|1B|ESC|
|28|1C|FS|29|1D|GS|30|1E|RS|31|1F|US|
|32|20|(space)|33|21|!|34|22|"|35|23|#|
|36|24|$|37|25|%|38|26|&|39|27|'|
|40|28|(|41|29|)|42|2A|*|43|2B|+|
|44|2C|,|45|2D|-|46|2E|.|47|2F|/|
|48|30|0|49|31|1|50|32|2|51|33|3|
|52|34|4|53|35|5|54|36|6|55|37|7|
|56|38|8|57|39|9|58|3A|:|59|3B|;|
|60|3C|<|61|3D|=|62|3E|>|63|3F|?|
|64|40|@|65|41|A|66|42|B|67|43|C|
|68|44|D|69|45|E|70|46|F|71|47|G|
|72|48|H|73|49|I|74|4A|J|75|4B|K|
|76|4C|L|77|4D|M|78|4E|N|79|4F|O|
|80|50|P|81|51|Q|82|52|R|83|53|S|
|84|54|T|85|55|U|86|56|V|87|57|W|
|88|58|X|89|59|Y|90|5A|Z|91|5B|[|
|92|5C|\|93|5D|]|94|5E|^|95|5F|_|
|96|60|`|97|61|a|98|62|b|99|63|c|
|100|64|d|101|65|e|102|66|f|103|67|g|
|104|68|h|105|69|i|106|6A|j|107|6B|k|
|108|6C|l|109|6D|m|110|6E|n|111|6F|o|
|112|70|p|113|71|q|114|72|r|115|73|s|
|116|74|t|117|75|u|118|76|v|119|77|w|
|120|78|x|121|79|y|122|7A|z|123|7B|{|
|124|7C|\||125|7D|}|126|7E|~|127|7F|DEL|

یعنی مرتب سازی براساس جدول بالاست که انجام میشه.

اما یه دستور پر کاربرد دیگه ای که داریم sed هست جلوش یه اسکریپت میگیره و یه فایل. خیلی کارهای متنوعی با regex و این sed میشه کرد اما یکی از پرکاربردترین هاش اینه که میتونیم replace کنیم.

```bash
sed 'script' file
```

```bash
sed 's/a/A' text
```

اینجا s برای تغییر است و گفتیم a رو با A عوض کن. خط به خط فایل رو جلو میره و اینکار رو میکنه اما در هر خط فقط اولین a رو A جابه جا میکنه اگر بخواهیم برای همه a ها اینکار رو کنیم g استفاده میکنیم

```bash
sed 's/a/A/g' text
```

### هش گرفتن 

اینجا اینو فقط کامندهاش رو میگیم

```bash
md5sum file
```

```
sha256sum file
```

```
sha128sum file
```