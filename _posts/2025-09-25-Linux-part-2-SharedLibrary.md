---
layout: post
title: "قسمت دوم آموزش لینوکس - Shared Library"
date: 2025-09-25 14:00:00 +0330
categories: linux lpic threat-hunting
image: /assets/images/Linux_Shared_Library_List.png
description: "در این بخش میخواهیم درباره Shared Library ها در لینوکس صبحت کنیم"
tag: [shared-library, linux, ldconfig, ldd, dynamic-linking, static-linking]
author: "amin Ghorbani"
---

## مدیریت Shared Libraryها

در اینجا میخواهیم درباره Shared Libraryها صبحت کنیم که در حقیقت تکه کدهایی که میتونن تابع یا کلاس باشند و به صورت کامپایل شده در سیستم قرار دارند و برنامه های مختلف میتوانند از آن ها استفاده کنند. این کتابخانه ها در لینوکس با پسوند so. شناخته میشوند ( در ویندوز dllها هستند ).
فرض کنید میخواهید یک برنامه بنویسید که نیازمند اتصال به اینترنت است، در اینجا شما نیازی نیست توابع ارسال درخواست های GET و POST را از صفر بنویسید کتابخانه ای با نام libcurl وجود دارد که همه برنامه ها زمانی که میخواهند درخواست HTTP ارسال کنند از توابع موجود در این کتابخانه استفاده میکنند.
بخوام یکم خودمانی بگم ببینید یه سری کارهای روتین وجود دارد که برنامه های مختلفی نیاز دارند انجام دهند در اینجا قرار نیست برنامه نویس ها خودشون چرخ رو از اول اختراع کنند یه سری برنامه نویس دیگه اومدن این توابع را پیاده سازی کردند و تحت عنوان یک package که اسمش رو میذاریم کتابخانه در اختیار بقیه قرار دادند.

حالا به این عملیات که من میخوام در برنامه خودم میخوام از این کتابخانه libcurl استفاده کنم باید اون رو با خودم لینک کنم که به این عملیات linking میگوییم این کار به دو صورت کلی انجام میشود :
1. Static Linking:
   اینجا من برنامه ام رو نوشتم کتابخانه های A , B , C هم نیاز دارم، کاری که میکنم این کتابخانه ها را به صورت کامل درون برنامه خودم قرار میدهم و یک فایل PE با حجم زیاد درست میشود.
2. Dynamic Linking:
   من تو برنامه ام خود کتابخانه ها را قرار نمیدهم فقط میگم این به کتابخانه A , B نیاز دارد اینجا سیستم عامل در زمانی که برنامه را اجرا میکند خودش میرود و اون کتابخانه ها را load میکند.

**اینجا میخوام از شما یه سوال کنم مزیت ها و معایب استفاده از هرکدوم این رو روش رو با خودتون فکر کنید**

اسم گذاری فایل های Library در لینوکس به شکل زیر است :
```bash
libLIbNAME.so.Version
```
معمولا هم در یکی از دو مسیر زیر هستند:

```
/lib*/
/usr/lib*/
```                                                                                                         
![تصویر دستور Linux_Shared_Library_List](/assets/images/Linux_Shared_Library_List.png)

برای اینکه لیست Library های یک برنامه رو بدست بیاریم از دستور زیر استفاده میکنیم

```bash
ldd /usr/bin/PEName
```
![تصویر دستور ldd_command](/assets/images/ldd_command.png)

فرض کنید من حالا میخوام از یه دستور دیگه به اسم ldconfig استفاده کنم و نمیدانم کجاست با دستور زیر اول آن را پیدا میکنم

```bash
locate dlconfig
```

خب حالا میریم ldd میگیریم:
```bash
ldd /usr/sbin/ldconfig
```

که میبینم این برنامه static لینک شده است.

فرض کنید من میخوام مسیر تمامی so ها را پیدا کنم

```bash
cat /etc/ld.so.conf
```
![تصویر دستور ldconfig](/assets/images/ld_config.png)

این نتیجه به ما میگه هرکی با این ها کار داشت به کجا باید رفت 
![تصویر دستور ldconfig](/assets/images/ldConf.png)

برنامه برای اینکه همین این مسیر ها را بگردد زمان بر است فلذا دستوری داریم به اسم ldconfig که یک فایل cache درست میکند و برنامه ها میرن اینو نگاه میکنن :)

```bash
ldconfig -p
```
![تصویر دستور ldconfig_command](/assets/images/ldconfig_command.png)

حالا یه سوال اساسی این است که وقتی یه برنامه رو اجرا میکنید کجاها دنبال این Shared Libها میگردد:
1. LD_LIBRARY_PATH environment variable
2. Program PATH
3. /etc/ld.so.conf
4. /lib/ , /lib64/, /usr/lib/ , /usr/lib64/

برای اینکه متغیرهای محیطی رو ببینی با دستور export در دسترس است برای دیدن LDها :

```bash
export | grep LD
```

برای افزودن LD_LIBRARY_PATH میتوانیم از دستور زیر استفاده کنیم

```bash
export LD_LIBRARY_PATH = /usr/lib/mylibs:/home/lib/
```
حالا اگر برنامه رو اجرا کنیم به ترتیب مسیرهای زیر را به دنبال LIBها میگردد:
1. /usr/lib/mylibs
2. /home/lib/
3. Program PATH
4. /etc/ld.so.conf
5. /lib/ , /lib64/, /usr/lib/ , /usr/lib64/

