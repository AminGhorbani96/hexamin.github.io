---
layout: post
title: "بیانیه یادگیری و آشنایی با Boot در لینوکس"
date: 2025-09-23 14:00:00 +0330
categories: linux lpic threat-hunting
image: assetsimages/linux-boot-cover.png
description: "یادگیری مفاهیم بوت در لینوکس، آشنایی با Firmware, Bootloader, Init و نقش آن‌ها در امنیت و شکار تهدید."
---
# بیانیه یادگیری 

هدف این دوره در نهایت این است که ما بتوانیم با سیستم های لینوکسی به خوبی کار کنیم و در نهایت بتوانیم عملیات شکارتهدید را در سرورهای لینوکسی انجام دهیم. یادمون باشه قرار نیست ما system admin باشیم و قرار نیست خط به خط و مو به مو از سرفصل های LPIC جلو بریم یه جاهایی احتمالا مسیرمون از این سرفصل خارج میشود تا بتوانیم با نگاه امنیت به موضوع بنگریم.
خواندن این داکیومنت بدون اینکه یه سیستم لینوکسی جلومون باشه و در خلال کار کمی سرچ کنیم به هیچ کارمون نمیاد.
# مقدمه

در این بخش قرار است درباره تنظیم سخت افزار و بوت شدن سیستم‌ها را یاد بگیریم.
# تخمین و تنظیم سخت افزار 

قبل از اینکه بخواهیم درباره لینوکس و نحوه کارکردن باهاش آشنا شویم نیاز است یه سری تعاریف رو در ذهن خودمون درست کنیم. 

وقتی ما صحبت از سیستم عامل میکنیم در حقیقت از برنامه ای صحبت میکنیم که رابط بین کاربر و سخت افزار است.سیستم عامل در حقیقت به کاربر و برنامه‌های کاربردی (Application) این اجازه را میدهد که با سخت افزار صحبت کنند. اما شاید اینجا بهتر باشه این موضوع را روشن کنیم که وقتی صحبت از سیستم عامل میکنیم منظورمان Kernel است. در حقیقت Kernel یک رابط بین User Programs و Hardware است. احتمالا الان براتون سوال پیش میاد وقتی صحبت از Kernel Mode  یا User Mode میکنیم منظورمان چیست؟
از اینجا به بعد یه قراری باهم میذاریم اونم این است که وقتی صحبت از Linux میکنیم منظور ما Kernel است، کرنل در حقیقت هسته اصلی سیستم عامل میباشد که ارتباط بین Applicationها و سخت افزار را برقرار میکند. یکی دیگر از وظایف Kernel مدیریت منابع سخت افزاری است. برای مثال مدیریت CPU, RAM, HARD DISK را کرنل است که انجام میدهد. تمام سیستم عامل هایی که ما میشناسیم دارای دو بخش کلی USER MODE و KERNEL MODE هستند. هسته اصلی سیستم عامل ها و آنچیزی که به عنوان رابط بین ما و سخت افزار است KERNEL میباشد، USER MODE به این منظور بوجود امده است که من و شما بتوانیم برنامه های خود را اجرا کنیم. (این تعریف شاید دقیق و عملی نباشد اما یک نگاه بالا به پایین و BLACK BOX است بدون اینکه بخواهیم الان ذهن خودمان را درگیر جزییات و رابطه این دو بخش کنیم.)
طی زمان باعث شد وقتی سخت افزاری ساخته میشود به صورت Embeded یک برنامه کوچک داخلشون گذاشته شود تا من و شما بتوانیم به راحتی ازش برای مدیریت سخت افزار استفاده کنیم.به این برنامه های کوچک Firmware میگوییم بخوام یه تعریف کوچک و تک جمله ای از آن داشته باشم باید بگویم:

**Firmware is a software on your hardware which run it**

اولین چیزی که من و شما باید از لینوکس بدانیم این است که وقتی ما دکمه پاور سیستمی که سیستم عامل آن لینوکس است را فشار میدهیم چه فرآیندی طی میشود تا سیستم عامل به صورت کامل Boot شود یا اصطلاحا سیستم ما بالا بیاد. شکل زیر رو با دقت ببینید
![[assetsimages/ image 20250919190643.png]]
قبل از اینکه ادامه متن رو بخونید عکس بالا رو با دقت نگاه کنید
گفتیم Firmware نرم افزاری است که برروی سخت افزار نصب است و دو کار را برای ما انجام میدهد :
1. بعد از اجرا اولین کاری که انجام میدهد POST (Power ON self test) است، یعنی چی؟ یعنی Firmware است که چک میکند سخت افزارهای متصل به Motherboard به درستی شناسایی میشوند یا ایرادی در آن ها وجود دارد
2. لودکردن BootLoader دیگر کاری است که انجام میدهد .

اما ما با دو نوع Firmware رو به رو هستیم:
1. نسخه قدیمی تر، BIOS است که به عنوان FIRMWARE برروی MOTHERBOARD نصب است و زمانی که MOTHERBOARD روشن میشود LOAD میگردد. BIOS اولین بخش از بوت لودر را که در پارتشین ابتدایی با نام MBR ذخیر شده است در حافظه بارگذاری میکند. در BIOS  مراحل بوت عبارتند از :
	1. تست اولیه سخت افزار که POST است.
	2. فعال سازی سخت افزارهای پایه مانند مانیتور، HARD و...
	3. بارگذاری BOOTLOADER از MBR
	4. اولین STAGE از بوت لودر که همان MBR است STAGE دوم که کرنل است را بارگذاری میکند.
2. نسخه UEFI این نسخه دیگر وابسته به پارتیشن MBR نیست، و از تنظیماتی که در حافظه NVRAM روی مادربورد تعبیه شده است استفاده میکند. برنامه های ذخیره شده در NVRAM میتواند نقش های مختلفی داشته باشند که یکی از این نقش ها BOOTLOADER است .در این حالت ما دارای یک پاریتشن جدا در مسیر boot/ هستیم که فایل ها در آن ذخیره شده اند. در این حالت اتفاقات زیر به ترتیب رخ میدهند :
	1. عملیات POST
	2. فعال سازی سخت افزار
	3. خواندن تنظیمات NVRAM
	4. اگر برنامه EFI انتخاب شده یک BOOTLOADER باشد کرنل LOAD میشود.
	در این حالت شما درصورتی که مسیر زیر را ls بگیرید با فایل هایی مواجه میشوید که پسوند آن ها efi. است 
```bash
ls /sys/firmware/efi
```

خب حالا نوبت BOOTLOADER است که خود یک درک کوچکی از سخت افزار دارد، میتواند کرنل را پیدا و LOAD نماید.

نکته ای که اینجا باید به آن دقت داشته باشید این است که سیستم در حالت لود شدن لاگ هایی را ایجاد میکند که در زمان مشکل میتواند برای ما مفید باشند. اما چالش اصلی اینجاست که در ابتدای مرحله load هنوز hardها جهت ذخیره سازی log شناسایی نشده اند. کرنل لینوکس برای حل این مشکل از kernel ring buffer استفاده میکند و لاگ های زمان بوت شدن را در آن ذخیره سازی مینماید. بعد از آن که سیستم عامل به صورت کامل boot شد شما میتواند با دستور زیر این لاگ ها را مشاهده کنید:

```bash
dmesg
```
همچنین پس از شناسایی هارددیسک با توجه به توزیع لینوکس این لاگ ها در یکی از مسیر های زیر ذخیره میشود که میتوانید آن ها را بخوانید:

```bash
cat /var/log/dmesg
```
```bash
cat /var/log/boot.log
```

یکی دیگر از راه های دستیابی به این لاگ ها مطالعه لاگ های موجود در journalctl است که با دستورات زیر میتوانید لاگ های مورد نیاز را بخوانید:
1. دسترسی به لاگ های کرنل
```bash
journalctl -k
```
2. دسترسی به لاگ های بوت
   ```bash
   journalctl -b
   ```

خب حالا که بوت لودر کرنل را بارگذاری کرده است، وقت آن رسیده که Processها و serviceها نیز اجرا شوند، کرنل در اینجا این کار را به سرویس init سپرده است، یعنی کرنل به صورت مستقیم پس از boot این سرویس را اجرا میکند که وظیفه اجرای برنامه های دیگر مانند ssh, apache و ... را برعهده دارد.

اینجا بد نیست بدانید ما سه نوع init در لینوکس داشته ایم :
1. نسخه upstart که توسط ubuntu در سال 2014 شروع شد اما شکست خورد و دیگر وجود ندارد.
2. نسخه sys V init که تا کرنل 5 وجود داشت و بسیار محبوب بود.
3. نسخه systemd که امروزه تمام توزیع های لینوکس از آن استفاده میکنند.
دقت کنید pid پراسس Init همیشه برابر 1 است و شما با دستور زیر میتوانید آن را ببینید:
```bash
ps -P 1
```

همچنین برای اینکه ببینید این فایل این پردازه کجاست کافیه از دستور زیر استفاده کنید:
```bash
$ which init
/usr/bin/init
```

حال نوبت آن است که با توجه به سلسله روند بوت شدن سیستم به سراغ BootLoader برویم.
معروف ترین بوت لودر در لینوکس GRUB نام دارد که توسط BIOS و UEFI صدا زده میشود. GRUB لیست سیستم عامل های در دسترس برای بوت را نمایش میدهد.

راه اندازی سیستم از جایی شروع میشود که بوت لودر، کرنل را در RAM بارگذاری میکند. از اینجا به بعد کرنل کنترل پردازنده را برعهده میگیرد و شروع به شناسایی سخت افزار و مدیریت حافظه میکند.
در اینجا کرنل فایل سیستم initramfs را باز میکند این فایل سیستم در RAM قراردارد و یک pseudo file system است ... احتمالا در اینجا کمی علامت سوال در ذهنتان ایجاد شده است اشکالی نداره کمی جلوتر در همین بخش این موضوع را توضیخ میدهیم.

 پردازه Init، زمانی که بوت لودر کرنل را لود میکند نوبت به آن میرسد که کرنل پردازه ها را اجرا نماید اما اینجا اتفاقی که رخ میدهد این است که کرنل پردازه init را اجرا میکند و init وظیفه اجرای سایر سرویس ها را برعهده دارد. init دارای سه نسخه مختلف است :
 1. نسخه SysV Standard : در این نسخه که قدیمی است و امروزه خیلی مورد استفاده نیست init براساس runlevel مشخص شده تصمیم میگیرد کدام سرویس ها را باید اجرا کند. حالا احتمالا باز سوال میشه Runlevel چیه؟ این را هم کمی جلوتر توضیح میدهیم.
2. نسخه Systemd : در سال های اخیر بسیاری از توضیع  های لینوکس از این نسخه استفاده میکنند.که قابلیت های بیشتری را دارند ...
3. نسخه upstart: که توسط ubuntu شروع و شکست خورد!!!!

خب اینجا وقشته من و شما وقتی داخل یک سیستم هستیم تشخیص بدیم نسخه Init ما چیست در اینجا کافی است ابتدا با دستور زیر مسیر اجرایی init را در سیستم بدست اوریم:
```bash
which init
```
پس از اینکه مسیر به دست امد میتوانیم ببینیم این فایل به کدام نسخه Init اشاره میکند
```bash
ls -alth /usr/sbin/init
```

 ![[assetsimages/ image 20250919184938.png]]
یادتونه در باره دیدن پیام های بوت سیستم با استفاده از journalctl صحبت کردیم اینجا باید بگیم این لاگ تنها در سیستم هایی که از systemd بهره میبرند در دسترس است و شما با دستور زیر میتوانید لاگ های مربوط به بوت های سیستم را مشاهده کنید

```bash
journalctl --list-boots
```
![[assetsimages/ image 20250919185618.png]]
ایندکس 0 یعنی بوت فعلی و -1 یعنی بوت قبلی و همینطور به قبل، این دسته بندی به شما کمک میکند لاگ های مربوط به هریک از بوت های مورد نیاز خورد را مشاهده کنید
```bash
journalctl -b -1
```

 
خب حالا وقتشه یه مقدار ابهامات گذشته رو باهم Clear کنیم اول بریم سراغ مفهوم RunLevel یا Target در لینوکس.
یکی از ویژگی های سیستم های Unix این است که عملکردهای مختلف سیستم توسط Processهای مختلف مدیریت میشوند این Process ها را در لینوکس Daemon یا به صورت کلی تر Service میگیم.خیلی از بخش های سطح پایین سیستم عامل توسط همین Daemonها کنترل میشوند. این که در سیستم عامل کدام یک از سرویس ها فعال باشد وابسته به هدف و نیازمندی سیستم است.
در توزیع های مختلف لینوکس این سرویس ها توسط یک برنامه و کانفیگ هایش کنترل میشوند که شما بتوانید آن ها را Stop یا Start کنید.
همانطور که قبلا گفتیم سه سرویس init که همان نقش مدیریت این Daemonها را برعهده دارد وجود دارد :
1. نسخه SysVinit
   نسخه قدیمی init است که تعدادی حالت از پیش تعریف شده سیستم را مشخص کرده است به هرکدام از این حالت ها RunLevel میگویند. در حقیقت این حالت ها برای این است که در زمان Boot شدن به کرنل بگیم وقتی بالا میاد SysV یا همان init قرار است کدام یک از Daemonها را اجرا کند. 6 Runlevel داریم که در جدول زیر مشخص شده است.

| **Runlevel**       | **نام انگلیسی**     | **شرح**                                                                                                           |
| ------------------ | ------------------- | ----------------------------------------------------------------------------------------------------------------- |
| **0**              | Halt / Shutdown     | خاموش‌کردن سیستم                                                                                                  |
| **1 / s / single** | Single User Mode    | حالت تک‌کاربره، بدون شبکه و سایر قابلیت‌های غیرضروری (حالت نگهداری/عیب‌یابی) که تنها با یوزر root میتوان وارد شد. |
| **2، 3، 4**        | Multi User Mode     | حالت چندکاربره؛ کاربران می‌توانند از طریق کنسول یا شبکه وارد شوند (Runlevelهای ۲ و ۴ معمولاً استفاده نمی‌شوند)    |
| **5**              | Multi User with GUI | حالت چندکاربره معادل با ۳، به اضافه‌ی ورود به سیستم در حالت گرافیکی                                               |
| **6**              | Reboot              | راه‌اندازی مجدد سیستم                                                                                             |
شما در سیستم عامل میتوانید مشخص کنید که در کدام یک از Runlevelهای جدول فوق بالا بیاید. یعنی مثلا فرض کنید در زمانی که گرافیک سیستم عامل شما با مشکل مواجه شده است میتوانید سیستم عامل را در حالت 1 بالا آورید و عیب یابی مورد نظر را انجام دهید.

2. نسخه systemd
   در این نسخه که امروزه در تمامی توزیع های لینوکس به کار گرفته شده است به هریک از این سرویس های موجود در سیستم عامل unit میگوییم. هر unit دارای یک فایل تنظیمات نیز است. در systemd این unitها در 7 دسته قرار میگیرند.
   
| **نوع واحد (Unit Type)** | **شرح**                                                                                                    |
| ------------------------ | ---------------------------------------------------------------------------------------------------------- |
| **service**              | متداول‌ترین نوع، برای منابع فعال سیستم که قابل شروع، توقف و load هستند.                                    |
| **socket**               | واحد سوکت (فایل‌سیستمی یا شبکه‌ای). هر socket یک service متناظر دارد که هنگام دریافت درخواست load می‌شود.  |
| **device**               | مرتبط با دستگاه‌های سخت‌افزاری شناسایی‌شده توسط کرنل. تنها با وجود قانون udev به‌عنوان واحد شناخته می‌شود. |
| **mount**                | تعریف نقطه‌ی اتصال (mount point) در فایل‌سیستم، مشابه ورودی در ‎`/etc/fstab`.                              |
| **automount**            | نقطه‌ی اتصال خودکار. هر automount یک mount متناظر دارد که هنگام دسترسی فعال می‌شود.                        |
| **target**               | گروهی از واحدها که به‌صورت یک واحد مدیریت می‌شوند.                                                         |
| **snapshot**             | حالت ذخیره‌شده از systemd manager (در همه توزیع‌ها پشتیبانی نمی‌شود).                                      |

دستور systemctl دستور اصلی کنترل این unit ها در systemd است. 

دستور start کردن سرویس

```bash
systemctl start sshd.service
```

دستور stop کردن سرویس

```bash
systemctl stop sshd.service
```

دستور restart کردن سرویس

```bash
systemctl restart sshd.service
```

دستور مشاهده وضعیت سرویس

```bash
systemctl status sshd.service
```

دستور فعال سازی سرویس

```bash
systemctl enable sshd.service
```


دستور غیرفعال کردن سرویس

```bash
systemctl disable sshd.service
```

خب حالا اینجا یه سوال تفاوت start با enable و بعدش stop  یا disable چیست؟
شما در دستورات start و stop درباره حیات فعلی سرویس حرف میزنید یعنی میگویید الان این سرویس اجرا شود یا متوقف گردد اما در enableو disable درباره حیاتش در زمان boot صحبت میکنیم یعنی وقتی سرویس enable میشود در حقیقت به سیستم عامل میگوییم هرگاه boot شدن systemd باید این سرویس را اجرا کند .

یکی دیگر از دستورات باحالی که در systemctl شما میتوانید استفاده کنید دستور cat هست که به شما این اجازه را میدهد تنظیمات متعلق به یک سرویس را ببینید

```bash
systemctl cat sshd.service
```
![[assetsimages/ image 20250920142653.png]]
در تصویر فوق تنظیمات سرویس را مشاهده میکنید برای مثال After به این معنی است که این سرویس بعد از کدام یک از unit ها اجرا میشود و موارد دیگری که پیشنهاد میکنم یه بار بخونید چون به اندازه کافی Clear و روشن است.

در Systemd دسته بندی سرویس ها در هنگام بوت که قبلا با نام RunLevel در SysV میشناختیم با عنوان Target شناخته میشود و شما با دستور systemctl isolate میتوانید به این targetها بروید

```bash
systemctl isolate multi-user.target
```
 همچنین شما میتوانید target که به عنوان default شناخته میشود را ست و یا مشاهده نمایید.
```bash
systemctl set-default multi-user.target
```

```bash
systemctl get-default
```

در اینجا 6 تارگت مختلف داریم
1. تارگت rescue
2. تارگت emergency
3. تارگت reboot
4. تارگت halt
5. تارگت poweroff

برای اینکه تمام unitهای موجود در سیستم را مشاهده نمایید و وضعیت enable / disable آن ها را ببنید میتوانید از دستور زیر مشاهده کنید

```bash
systemctl list-unit-files
```
![[assetsimages/ image 20250920143429.png]]
همچنین میتوانید یک فیلتر براش قرار بدهید تا فقط target unitها را ببینید

```bash
systemctl list-unit-files --type= target
```
![[assetsimages/ image 20250920143540.png]]

## خاموش کردن سیستم
در خاموش کردن سیستم سه حالت کلی وجود دارد :
1. حالت halt : تمام پراسس ها stop میشن اما هنوز برق در cpu هست
2. حالت poweroff : برق نیز قطع میشود
3. حالت reboot
شما در زمانی که با سیستم کار میکنید توقع دارید که به یکباره نفر دیگری سیستم را خاموش نکند! لینوکس در سازمان ها معمولا در سیستم های سروری استفاده میشود و ممکن است در لحظه ای که من در حال انجام کاری در آن هستم شما نیز با user خود به سرور وصل باشید و نیاز داشته باشید سیستم را reboot کنید در حالی که reboot کردن شما اختلال در کار من است. برای اینکه این اتفاق رخ ندهد شما زمانی که از دستور shutdown استفاده میکنید میتوانید یک wall قرار دهید که به همه ترمینال های متصل خبر دهید قصد دارید سیستم را reboot کنید و بگویید سیستم 5 دقیقه دیگر reboot شود
```bash
shutdown -r +5 "This machine reboot after 5 minutes"
```
![[assetsimages/ image 20250920144716.png]]
![[assetsimages/ image 20250920144724.png]]

برای کنسل کردن shutdown
```bash
shutdown -c
```


**اما سوال الان اینه لینوکس چطور با سخت افزارهای مختلف ارتباط میگیرد؟**

در لینوکس یک pseudo file system وجود دارد با نام sysfs که میتوانید در مسیر sys/ آن را ببینید این فایل سیستم در حافظه Ram اختصاص یافته به kernel لود میشود. دقت کنید در RAM نه HARD و اجازه میدهد که kernel اطلاعات سخت افزارها و device از kernel mode به user mode نمایش دهد و میشه اون رو یه پل در نظر گرفت بین kernel objectها که همان bus, driver, device ,... هستند با user mode خب پس این مقادیر در کجا هستند در ram ولی شما در مسیر sys/ میتوانید ببینید :

```bash
ls /sys
```

![[assetsimages/ image 20250920162546.png]]
در لینوکس دستوراتی هستند که به شما یه سری اطلاعات از سخت افزارهای متصل به سیستم نشان میدهند برای مثال دستورات زیر:
1. دستور lsusb که سخت افزارهای متصل از درگاه usb را به ما نشان میدهد
2. دستور lspci که سخت افزارهای متصل از طریق PCI را نمایش میدهد
این دستورات هم برای اینکه به ما داده های خود را نشان دهند به سراغ همین sys/ میروند

دومین چیزی که اینجا برایمان مهم میشود udev است که یک daemon در لینوکس است و وظیفه مدیریت hardwareها در زمان اجراست. زمانی که یک دستگاه به سیستم متصل میشود این سرویس device file مناسب را در مسیر dev/ میسازد و شما در اینجا میتوانید آن ها را ببینید. این سرویس در حقیقت device manager سیستم های لینکوسی است.

در حقیقت sysfs اطلاعات کرنل و سخت افزار را در sys/ به ما میدهد، و udev به محض اینکه کرنل یک device جدید را شناسایی میکند اطلاعات آن را در dev/ قرار میدهد.

در حقیقت لینوکس با استفاده از sysfs و udev شما را به سخت افزار متصل میکند و سخت افزارها را به صورت فایل به من و شما نشان میدهد.

خب یکی از کاربردهای مهم اینجا مثلا دیدن Hard Diskهای متصل به سیستم است 

```bash
ls /dev
```

![[assetsimages/ image 20250920163901.png]]

در اینجا sda1 , sda2 پارتیشن های دیسک اول است . یعنی فایل های sdx نشان دهنده Hard diskهای متصل و عدد مقابل آن ها نشان دهنده پارتیشن هاست . sda1 یعنی پارتیشن اول هارد اول، sdc2 یعنی پارتیشن دوم هارد سوم!

همچنین دستور lsblk بلاک های حافظه شما را نمایش میدهد
```bash
lsblk
```
![[assetsimages/ image 20250920164248.png]]

در لینوکس ما FHS یا همان File system hierarchy داریم یعنی فارق از اینکه چند Hard به سیستم متصل است ما یک فایل سیستم درختی داریم که ریشه آن / است که بهش root میگیم درحالی که در ویندوز وقتی شما دوتا هارد دارید برای مثال یکی درایو C شماست و یکی درایو D !  اما در لینوکس شما یک فایل سیستم درختی دارید . در پوشه / میتوانید Folderهای موجود را ببینید که بد نیست یه آشنایی کلی اینجا داشته باشید :


| دایرکتوری | توضیح                                                                                                        |
| --------- | ------------------------------------------------------------------------------------------------------------ |
| `/bin`    | فایل‌های اجرایی پایه لینوکس که همه کاربران می‌توانند از آن‌ها استفاده کنند                                   |
| `/boot`   | فایل‌های مربوط به بوت سیستم، شامل کرنل و فایل‌های GRUB                                                       |
| `/dev`    | اطلاعات مربوط به سخت‌افزارها و device files                                                                  |
| `/etc`    | فایل‌های کانفیگ سیستم و برنامه‌ها                                                                            |
| `/home`   | پروفایل‌ها و فایل‌های کاربران عادی                                                                           |
| `/lib`    | کتابخانه‌ها و ماژول‌های کرنل و درایورها                                                                      |
| `/media`  | محل mount دستگاه‌های removable مانند USB یا CD/DVD                                                           |
| `/mnt`    | محل mount موقت فایل‌سیستم‌ها                                                                                 |
| `/opt`    | محل نصب برنامه‌های کاربردی third-party یا اختیاری                                                            |
| `/root`   | پروفایل و home یوزر root                                                                                     |
| `/sbin`   | فایل‌های اجرایی سیستم که نیاز به دسترسی سطح بالا دارند (root)                                                |
| `/tmp`    | محل ذخیره فایل‌های موقت برنامه‌ها و سیستم                                                                    |
| `/usr`    | فایل‌سیستم شبیه ریشه، شامل باینری‌ها، کتابخانه‌ها و اسناد؛ اکثر مسیرها در آن لینک به دیگر دایرکتوری‌ها دارند |

## پارتیشن‌ها در لینوکس

به بخش هایی از یک HARD میگیم، شما زمانی که یه هارد را در سیستم قرار میدهید برای استفاده باید اصطلاحا آن را Format نمایید و Partitionهایش را مشخص کنید.
فرض کنید شما 1TB هارد دارید و آن را به سه بخش یا بهتر بگیم پارتیشن با حجم های 500GB, 200GB, 300GB تقسیم میکنید در ویندوز اگر اینکار را کنید سه درایو C و D و E ساخته میشود اما در لینوکس فایل سیستم به صورت در ختی است و همه ذیل یک پوشه / که آن را ریشه یا همان root مینامیم قرار میگیرند.
حتی زمانی که در لینوکس USB Disk خود را به ماشین متصل میکنید چیزی شبیه Drive ساخته نمیشود و فقط یک پوشه در همان فایل سیستم درختی لینوکس ایجاد میشود.
![[assetsimages/ image 20250922140825.png]]

تصویر بالا را در نظر بگیرید در حقیقت ما یه Partition باحجم 250MB داریم که فایل های مربوط به بوت را در آن قرار دادیم این باعث میشود این بخش در زمان بوت سریع لود بشه و بتوانیم در صورتی که سیستم عامل خراب شد به راحتی چیز دیگری را بوت نماییم، فایل های اصل را در پارتیشن / و فایل های مربوط به کاربر را در home قرار میدهیم
در گذشته اشاره کرده بودیم اگر شما دو هارد متصل داشته باشید در dev/ قابل مشاهده اند و با نام های sda و sdb نمایش داده میشوند حالا اگر sdaسه پارتیشن داشته باشد این سه پارتیشن را با نام های sda1, sda2, sda3 میتوانید ببینید.
برای مشاهده پارتیشن بندی سیستم میتوانید از دستورات زیر استفاده کنید.

```bash
fdisk /dev/sda
```
دستور بالا شما را وارد یک محیط تعاملی میکند که با دادن دستور p پارتیشن ها را میتوانید ببینید
![[assetsimages/ image 20250922141503.png]]

```bash
parted  /dev/sda
```
دستور بالا شما را وارد یک محیط تعاملی میکند که با دادن دستور p پارتیشن ها را میتوانید ببینید
![[assetsimages/ image 20250922141637.png]]

خب حالا که این مفهوم Partition رو فهمیدیم خوبه بریم و کمی درباره LVM صحبت کنیم :)
فرض کنید ما میخواهیم یک Application برروی یک سرور لینوکسی Lunch کنیم این APPLication نیاز به 30TB هارد یکپارچه دارد. خب قاعدتا ما در بازار همچین هاردی را پیدا نمیکنیم ... لینوکس برای این موضوع یه فکر خوبی کرده است و آن را در مفهمومی به نام Logical Volume Management یا همان LVM به ما ارائه کرده است.در این شرایط شما میتوانید با این قابلیت به جای یک هارد 30TB از 6 هارد 5TB استفاده کنید و آن ها را به نحوی با استفاده از این مفهوم تحت عنوان یک هارد 30TB به سیستم عامل معرفی کنید و بعد هم بر اساس اینکه هارد شما 30TBاست عملیات پارتیشن بندی را انجام دهید.
در این مفهوم به اون 6 هارد فیزیکی Physical Volume، به هارد یک تیکه ای که سیستم عامل آن را میشناسد Logical Volume و به مجموعه دیسک هایی که باهم همکروی شده است Volume Group میگوییم.
![[assetsimages/ image 20250923134901.png]]
درحالت پیش فرض شما اون هارد LVM شده یا حتی یک تک هارد که دارید Linux خود را در آن نصب میکنید به صورت زیر است:


![[assetsimages/ image 20250923133209.png]]

در تصویر بالا نشان میدهد که یک پارتیشن بندی کلی انجام شده است که فایل های مربوط به boot در پارتیشن boot، فایل های اصلی سیستم در یک پارتیشن به نام / و فایل های مربوط به پروفایل کاربران در home/ قرار میگیرد اما اینجا یک پارتیشن با نام swap نیز داریم.

**اما swap چیه؟**
فرض کنید ما 4gb رم در سیستم خود داریم و نیاز داریم برنامه هایمان مجموعا 6gb رم استفاده کنند،   linux اون 2gb رم اضافه را در فایل ذخیره میکند و به برنامه های کاربردی موجود در سیستم این اجازه را میدهد که بیش از رم واقعی سیستم استفاده کنند. روش بسیار مرسومی است که شما برای ذخیره سازی فایل swap که به همین منظور ساخته میشود یک پارتیشن جدا در هارد خود بسازید. اما خب این پارتیشن چقدر فضا نیاز دارد؟

با توجه به اینکه خواندن از Swap فایل بسیار کند است بسته به اینکه هارد HDD است یا SSD این موضوع متغیر است البته همه این ها Best Practice است و اگر شما فضای کمتر یا بیشتر بدهید با ERROR مواجه نمیشوید.

در هاردهای HDD گفته میشود بهتر است دو برابر مقدار RAM واقعی اما کمتر از 8gb به SWAP فضا دهیم. یعنی اگر شما 2GB رم در سیستم دارید مقدار SWAP میشود 4GB اما اگر 8GB رم واقعی سیستم است باید همان 8GB را به پارتیشن SWAP اختصاص دهید.

اما اگر از هارد SSD استفاده میکنید بهتر است از فرمول زیر برای اختصاص فضا به SWAP استفاده کنید
```MATH
SAWP_VOLUME = PHYSICAL_RAM + 2
```
یکی از حالت هایی که SWAP بسیار کاربرد دارد زمانی است که سیستم را HIBERNATE میکنید اینجا تمامی مقادیر موجود در RAM به داخل فایل SWAP میرود و زمانی که مجدد راه اندازی میشود این مقادیر در RAM بارگذاری میشود.


پارتیشن بندی HARD بر اساس نیازهای شما تعیین میشود برای مثال در یک سیستم شبکه که نفرات زیادی در آن LOGIN میکنند و هرکس PROFILE خود را دارید پارتیشن HOME جدا میشود و مقدار مورد نیاز به این پارتیشن اختصاص داده میشود


![[assetsimages/ image 20250923134658.png]]

اما زمانی که سیستم LINUX قرار است یک وب سرور باشد که مقادیر زیادی لاگ در خود ذخیره میکنند خوب است که VAR/ را که لاگ ها در آن قرار میگیرد جدا کرده و مقدار کافی دیسک بهش اختصاص بدیم
![[assetsimages/ image 20250923134837.png]]


اینجا شاید بهتر باشد درباره SWAP بیشتر صحبت کنیم. مکانیزم های SWAP, VIRTUAL MEMEORY, PAGING به سیستم اجازه میدهد که کارهایی را انجام دهند که به RAM بیشتر از سیستم نیاز دارند انجام دهند.
شما با دستور زیر میتوانید میزان RAM سیستم را ببینید :
```bash
free -h
```
![[assetsimages/ image 20250923135355.png]]
برای پیدا کردن فایل swap در سیستم هم از دستور زیر استفاده میکنیم:

```bash
swapon
```
![[assetsimages/ image 20250923135613.png]]
در سیستم عامل های Fedora اما این دستور خروجی متفاوتی دارد
![[assetsimages/ image 20250923145727.png]]
همانطور که میبینید در سیستم فدورایی پارتیشن swap با عنوان zram نمایش داده میشود
برخلاف بقیه جاها که swap روی هارد ذخیره میشود zram در حقیقت در همان RAM است. هدف اصلی SWAP را یادمون بیاریم قرار بود بتوانیم کارهایی را انجام دهیم که مقدار RAM بیشتر از RAM حقیقی نیاز دارد،FEDORA برای اینکار داده های داخل RAM را فشرده میکند و در همان RAM یه بخش را به SWAP اختصاص میدهد که به آن zram میگوییم.
